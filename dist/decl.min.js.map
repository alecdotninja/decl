{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/mutation-observer/index.js","src/decl.ts","src/element_collector.ts","src/scope.ts","src/subscriptions/batched_mutation_subscription.ts","src/subscriptions/element_matches_subscription.ts","src/subscriptions/event_subscription.ts","src/subscriptions/matching_elements_subscription.ts","src/subscriptions/subscription.ts","src/subscriptions/trivial_subscription.ts"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","scheduleCallback","observer","scheduledObservers","push","isScheduled","setImmediate","dispatchCallbacks","wrapIfNeeded","node","window","ShadowDOMPolyfill","observers","sort","o1","o2","uid_","anyNonEmpty","forEach","queue","takeRecords","removeTransientObserversFor","callback_","nodes_","registrations","registrationsTable","get","registration","removeTransientObservers","forEachAncestorAndObserverEnqueueRecord","target","callback","parentNode","j","options","subtree","record","enqueue","JsMutationObserver","this","records_","uidCounter","MutationRecord","type","addedNodes","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","copyMutationRecord","original","slice","getRecord","currentRecord","getRecordWithOldValue","recordWithOldValue","clearRecords","undefined","recordRepresentsCurrentMutation","selectRecord","lastRecord","newRecord","Registration","transientObservedNodes","MutationObserver","WebKitMutationObserver","MozMutationObserver","WeakMap","defineProperty","Object","counter","Date","now","name","Math","random","prototype","set","key","value","entry","writable","delete","hasValue","has","msSetImmediate","setImmediateQueue","sentinel","String","addEventListener","data","func","postMessage","observe","childList","attributes","characterData","attributeOldValue","attributeFilter","characterDataOldValue","SyntaxError","removeListeners","addListeners","disconnect","splice","copyOfRecords","records","recordToReplaceLast","addListeners_","removeListeners_","removeEventListener","addTransientObserver","handleEvent","stopImmediatePropagation","attrName","namespace","relatedNode","namespaceURI","attrChange","MutationEvent","ADDITION","prevValue","indexOf","changedNode","scope_1","Scope","default","Decl","root","scope","buildRootScope","select","matcher","executor","getDefaultInstance","on","getRootScope","collectScopes","drawTree","defaultInstance","document","documentElement","setDefaultInstance","decl","pristine","concat","collectDescendantScopes","isArrayLike","toArray","arrayLike","Array","TypeError","isMemberOfArrayLike","haystack","needle","ElementCollector","isMatchingElement","rootElement","elementMatcher","getInstance","collectMatchingElements","instance","element","ELEMENT_MATCHER_TYPE_ERROR_MESSAGE","cssSelector","isMatchingElementFromCssSelector","object","isMatchingElementFromObject","elementVistor","isMatchingElementFromElementVistor","collectMatchingElementsFromCssSelector","collectMatchingElementsFromObject","collectMatchingElementsFromElementVistor","matches","querySelectorAll","Element","visitorResult","elements","_i","_a","children","child","element_1","apply","trivial_subscription_1","matching_elements_subscription_1","element_matches_subscription_1","event_subscription_1","parentScope","childScopes","isActivated","subscriptions","activate","getParentScope","getChildScopes","scopes","drawTreeLines","join","lines","self","_b","_c","line","getElement","match","addSubscription","TrivialSubscription","connected","unmatch","disconnected","MatchingElementsSubscription","buildSelectExecutor","when","ElementMatchesSubscription","buildWhenExecutor","eventMatcher","executorOrElementMatcher","maybeExecutor","argumentsCount","arguments","onWithTwoArguments","onWithThreeArguments","EventSubscription","connect","deactivate","orphanedChildScope","console","warn","destroyChildScope","subscription","removeSubscription","index","_this","event","addedElements","createChildScope","removedElements","element_2","length_1","isMatching","subscription_1","Subscription","SubscriptionEvent","BatchedMutationSubscription","_super","isListening","handleMutationTimeout","mutationCallback","deferHandleMutations","mutationObserver","__extends","startListening","mutationObserverInit","stopListening","handleMutationsNow","setTimeout","handleMutations","clearTimeout","batched_mutation_subscription_1","element_collector_1","isConnected","updateIsMatchingElement","computeIsMatchingElement","wasMatchingElement","event_1","ElementMatchesChangedEvent","elementMatchesSubscription","eventNames","parseEventMatcher","eventListener","eventName","split","arraySubtract","minuend","subtrahend","difference","minuend_1","member","matchingElements","updateMatchingElements","previouslyMatchingElements","MatchingElementsChangedEvent","matchingElementsSubscription","ElementConnectionChangedEvent","trivialSubscription","config","buildElementConnectionChangedEvent"],"mappings":"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","file":"decl.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var MutationObserver = window.MutationObserver\n  || window.WebKitMutationObserver\n  || window.MozMutationObserver;\n\n/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nvar WeakMap = window.WeakMap;\n\nif (typeof WeakMap === 'undefined') {\n  var defineProperty = Object.defineProperty;\n  var counter = Date.now() % 1e9;\n\n  WeakMap = function() {\n    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n  };\n\n  WeakMap.prototype = {\n    set: function(key, value) {\n      var entry = key[this.name];\n      if (entry && entry[0] === key)\n        entry[1] = value;\n      else\n        defineProperty(key, this.name, {value: [key, value], writable: true});\n      return this;\n    },\n    get: function(key) {\n      var entry;\n      return (entry = key[this.name]) && entry[0] === key ?\n          entry[1] : undefined;\n    },\n    'delete': function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      var hasValue = entry[0] === key;\n      entry[0] = entry[1] = undefined;\n      return hasValue;\n    },\n    has: function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      return entry[0] === key;\n    }\n  };\n}\n\nvar registrationsTable = new WeakMap();\n\n// We use setImmediate or postMessage for our future callback.\nvar setImmediate = window.msSetImmediate;\n\n// Use post message to emulate setImmediate.\nif (!setImmediate) {\n  var setImmediateQueue = [];\n  var sentinel = String(Math.random());\n  window.addEventListener('message', function(e) {\n    if (e.data === sentinel) {\n      var queue = setImmediateQueue;\n      setImmediateQueue = [];\n      queue.forEach(function(func) {\n        func();\n      });\n    }\n  });\n  setImmediate = function(func) {\n    setImmediateQueue.push(func);\n    window.postMessage(sentinel, '*');\n  };\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n * @param {MutationObserver} observer\n */\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    setImmediate(dispatchCallbacks);\n  }\n}\n\nfunction wrapIfNeeded(node) {\n  return window.ShadowDOMPolyfill &&\n      window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n      node;\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort(function(o1, o2) {\n    return o1.uid_ - o2.uid_;\n  });\n\n  var anyNonEmpty = false;\n  observers.forEach(function(observer) {\n\n    // 2.1, 2.2\n    var queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      observer.callback_(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty)\n    dispatchCallbacks();\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes_.forEach(function(node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      return;\n    registrations.forEach(function(registration) {\n      if (registration.observer === observer)\n        registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options;\n\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree)\n          continue;\n\n        var record = callback(options);\n        if (record)\n          registration.enqueue(record);\n      }\n    }\n  }\n}\n\nvar uidCounter = 0;\n\n/**\n * The class that maps to the DOM MutationObserver interface.\n * @param {Function} callback.\n * @constructor\n */\nfunction JsMutationObserver(callback) {\n  this.callback_ = callback;\n  this.nodes_ = [];\n  this.records_ = [];\n  this.uid_ = ++uidCounter;\n}\n\nJsMutationObserver.prototype = {\n  observe: function(target, options) {\n    target = wrapIfNeeded(target);\n\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData ||\n\n        // 1.2\n        options.attributeOldValue && !options.attributes ||\n\n        // 1.3\n        options.attributeFilter && options.attributeFilter.length &&\n            !options.attributes ||\n\n        // 1.4\n        options.characterDataOldValue && !options.characterData) {\n\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations)\n      registrationsTable.set(target, registrations = []);\n\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    var registration;\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes_.push(target);\n    }\n\n    registration.addListeners();\n  },\n\n  disconnect: function() {\n    this.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records_ = [];\n  },\n\n  takeRecords: function() {\n    var copyOfRecords = this.records_;\n    this.records_ = [];\n    return copyOfRecords;\n  }\n};\n\n/**\n * @param {string} type\n * @param {Node} target\n * @constructor\n */\nfunction MutationRecord(type, target) {\n  this.type = type;\n  this.target = target;\n  this.addedNodes = [];\n  this.removedNodes = [];\n  this.previousSibling = null;\n  this.nextSibling = null;\n  this.attributeName = null;\n  this.attributeNamespace = null;\n  this.oldValue = null;\n}\n\nfunction copyMutationRecord(original) {\n  var record = new MutationRecord(original.type, original.target);\n  record.addedNodes = original.addedNodes.slice();\n  record.removedNodes = original.removedNodes.slice();\n  record.previousSibling = original.previousSibling;\n  record.nextSibling = original.nextSibling;\n  record.attributeName = original.attributeName;\n  record.attributeNamespace = original.attributeNamespace;\n  record.oldValue = original.oldValue;\n  return record;\n};\n\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord, recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue)\n    return recordWithOldValue;\n  recordWithOldValue = copyMutationRecord(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * @param {MutationRecord} record\n * @return {boolean} Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n *\n * @param {MutationRecord} lastRecord\n * @param {MutationRecord} newRecord\n * @param {MutationRecord}\n */\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord)\n    return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n    return recordWithOldValue;\n\n  return null;\n}\n\n/**\n * Class used to represent a registered observer.\n * @param {MutationObserver} observer\n * @param {Node} target\n * @param {MutationObserverInit} options\n * @constructor\n */\nfunction Registration(observer, target, options) {\n  this.observer = observer;\n  this.target = target;\n  this.options = options;\n  this.transientObservedNodes = [];\n}\n\nRegistration.prototype = {\n  enqueue: function(record) {\n    var records = this.observer.records_;\n    var length = records.length;\n\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  },\n\n  addListeners: function() {\n    this.addListeners_(this.target);\n  },\n\n  addListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.addEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.addEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.addEventListener('DOMNodeRemoved', this, true);\n  },\n\n  removeListeners: function() {\n    this.removeListeners_(this.target);\n  },\n\n  removeListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.removeEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.removeEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.removeEventListener('DOMNodeRemoved', this, true);\n  },\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   * @param {Node} node\n   */\n  addTransientObserver: function(node) {\n    // Don't add transient observers on the target itself. We already have all\n    // the required listeners set up on the target.\n    if (node === this.target)\n      return;\n\n    this.addListeners_(node);\n    this.transientObservedNodes.push(node);\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      registrationsTable.set(node, registrations = []);\n\n    // We know that registrations does not contain this because we already\n    // checked if node === this.target.\n    registrations.push(this);\n  },\n\n  removeTransientObservers: function() {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n\n    transientObservedNodes.forEach(function(node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  },\n\n  handleEvent: function(e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    switch (e.type) {\n      case 'DOMAttrModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n\n        // 1.\n        var record = new getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n\n        // 2.\n        var oldValue =\n            e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.attributes)\n            return;\n\n          // 3.2, 4.3\n          if (options.attributeFilter && options.attributeFilter.length &&\n              options.attributeFilter.indexOf(name) === -1 &&\n              options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.4, 4.5\n          return record;\n        });\n\n        break;\n\n      case 'DOMCharacterDataModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n        var target = e.target;\n\n        // 1.\n        var record = getRecord('characterData', target);\n\n        // 2.\n        var oldValue = e.prevValue;\n\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.characterData)\n            return;\n\n          // 3.2, 4.3\n          if (options.characterDataOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.3, 4.4\n          return record;\n        });\n\n        break;\n\n      case 'DOMNodeRemoved':\n        this.addTransientObserver(e.target);\n        // Fall through.\n      case 'DOMNodeInserted':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        var target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === 'DOMNodeInserted') {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n\n        // 1.\n        var record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 2.1, 3.2\n          if (!options.childList)\n            return;\n\n          // 2.2, 3.3\n          return record;\n        });\n\n    }\n\n    clearRecords();\n  }\n};\n\nif (!MutationObserver) {\n  MutationObserver = JsMutationObserver;\n}\n\nmodule.exports = MutationObserver;\n","import { Scope, ScopeExecutor, ElementMatcher, EventMatcher, SubscriptionExecutor } from './scope';\n\nexport default Decl;\n\nexport class Decl {\n    private static defaultInstance: Decl;\n\n    static select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        return this.getDefaultInstance().select(matcher, executor);\n    }\n\n    static on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.getDefaultInstance().on(matcher, executor);\n    }\n\n    static getRootScope(): Scope {\n        return this.getDefaultInstance().getRootScope();\n    }\n\n    static collectScopes(): Scope[] {\n        return this.getDefaultInstance().collectScopes();\n    }\n\n    static drawTree(): string {\n        return this.getDefaultInstance().drawTree();\n    }\n\n    static getDefaultInstance() : Decl {\n        return this.defaultInstance || (this.defaultInstance = new Decl(document.documentElement));\n    }\n\n    static setDefaultInstance(decl: Decl) : Decl {\n        return this.defaultInstance = decl;\n    }\n\n    static pristine(): void {\n        if(this.defaultInstance) {\n            this.defaultInstance.pristine();\n            this.defaultInstance = null;\n        }\n    }\n\n    private scope: Scope;\n\n    constructor(root: Element) {\n        this.scope = Scope.buildRootScope(root);\n    }\n\n    select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        return this.scope.select(matcher, executor);\n    }\n\n    on(matcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        return this.scope.on(matcher, executor);\n    }\n\n    getRootScope(): Scope {\n        return this.scope;\n    }\n    \n    collectScopes(): Scope[] {\n        return [this.scope, ...this.scope.collectDescendantScopes()];\n    }\n\n    drawTree(): string {\n        return this.scope.drawTree();\n    }\n\n    pristine(): void {\n        this.scope.pristine();\n    }\n}\n\n// Export to a global for the browser (there *has* to be a better way to do this!)\nif(typeof(window) !== 'undefined') {\n    (<any>window).Decl = Decl;\n}\n\nexport { Scope, ScopeExecutor, ElementMatcher, EventMatcher, SubscriptionExecutor };\n","export default ElementCollector;\n\nexport interface ElementVistor { (element: Element): ElementMatcher | boolean }\nexport declare type ElementMatcher = string | NodeListOf<Element> | Element[] | ElementVistor;\n\nexport class ElementCollector {\n    private static instance: ElementCollector;\n    \n    private static readonly ELEMENT_MATCHER_TYPE_ERROR_MESSAGE = \"Decl: An `ElementMatcher` must be a CSS selector (string) or a function which takes a node under consideration and returns a CSS selector (string) that matches all matching nodes in the subtree, an array-like object of matching nodes in the subtree, or a boolean value as to whether the node should be included (in this case, the function will be invoked again for all children of the node).\";\n\n    static isMatchingElement(rootElement: Element, elementMatcher: ElementMatcher): boolean {\n        return this.getInstance().isMatchingElement(rootElement, elementMatcher);\n    }\n\n    static collectMatchingElements(rootElement: Element, elementMatcher: ElementMatcher): Element[] {\n        return this.getInstance().collectMatchingElements(rootElement, elementMatcher);\n    }\n\n    private static getInstance() : ElementCollector {\n        return this.instance || (this.instance = new ElementCollector());\n    }\n\n    isMatchingElement(element: Element, elementMatcher: ElementMatcher): boolean {\n        switch(typeof(elementMatcher)) {\n            default:\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>elementMatcher;\n                return this.isMatchingElementFromCssSelector(element, cssSelector);\n            \n            case 'object':\n                let object = <Object>elementMatcher;\n                return this.isMatchingElementFromObject(element, object);\n                \n            case 'function':\n                let elementVistor = <ElementVistor>elementMatcher;\n                return this.isMatchingElementFromElementVistor(element, elementVistor);       \n        }\n    }\n\n    collectMatchingElements(element: Element, elementMatcher: ElementMatcher): Element[] {\n        switch(typeof(elementMatcher)) {\n            default:\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                \n            case 'string':\n                let cssSelector: string = <string>elementMatcher;\n                return this.collectMatchingElementsFromCssSelector(element, cssSelector);\n\n            case 'object':\n                let object = <Object>elementMatcher;\n                return this.collectMatchingElementsFromObject(element, object);\n                \n            case 'function':\n                let elementVistor = <ElementVistor>elementMatcher;\n                return this.collectMatchingElementsFromElementVistor(element, elementVistor);       \n        }\n    }\n\n    private isMatchingElementFromCssSelector(element: Element, cssSelector: string): boolean {\n        if(typeof(element.matches) === 'function') { // take a shortcut in modern browsers\n            return element.matches(cssSelector);\n        }else{\n            return isMemberOfArrayLike(document.querySelectorAll(cssSelector), element);\n        }\n    }\n\n    private isMatchingElementFromObject(element: Element, object: Object): boolean {\n        if(object === null) {\n            return false;\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Element) {\n                    return isMemberOfArrayLike(arrayLike, element);                \n                }else{\n                    throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private isMatchingElementFromElementVistor(element: Element, elementVistor: ElementVistor): boolean {\n        let visitorResult = elementVistor(element);\n\n        if(typeof(visitorResult) === 'boolean') {\n            let isMatch = <boolean>visitorResult;\n            return isMatch;\n        }else{\n            let elementMatcher = <ElementMatcher>visitorResult;\n            return this.isMatchingElement(element, elementMatcher);\n        }\n    }\n\n    private collectMatchingElementsFromCssSelector(element: Element, cssSelector: string): Element[] {\n        return toArray<Element>(element.querySelectorAll(cssSelector));\n    }\n\n    private collectMatchingElementsFromObject(element: Element, object: Object): Element[] {\n        if(object === null) {\n            return [];\n        }else{\n            if(isArrayLike(object)) {\n                let arrayLike = <ArrayLike<any>>object;\n\n                if(arrayLike.length === 0 || arrayLike[0] instanceof Element) {\n                    return toArray<Element>(arrayLike);                \n                }else{\n                    throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n                }\n            }else{\n                throw new TypeError(ElementCollector.ELEMENT_MATCHER_TYPE_ERROR_MESSAGE);\n            }\n        }\n    }\n\n    private collectMatchingElementsFromElementVistor(element: Element, elementVistor: ElementVistor): Element[] {\n        let elements: Element[] = [];\n\n        // I'm fibbing to the compiler here. `element.children` is a `NodeListOf<Element>`,\n        // which does not have a compatable interface with `Array<Element>`; however, the\n        // generated code still works because it doesn't actually use very much of the \n        // `Array` interace (it really only assumes a numberic length property and keys for\n        // 0...length). Casting to `any` here destroys that type information, so the \n        // compiler can't tell there is an issue and allows it without an error.\n        for(let child of <any>element.children) {\n            if(child instanceof Element) {\n                let element: Element = child;\n                let visitorResult = elementVistor(element);\n\n                if(typeof(visitorResult) === 'boolean') {\n                    let isMatch = <boolean>visitorResult;\n\n                    if(isMatch) {\n                        elements.push(element);\n                    }\n                }else{\n                    elements.push(...this.collectMatchingElements(element, visitorResult));\n                }\n            }\n        }\n\n        return elements;\n    }\n}\n\nfunction isArrayLike(value: any) {\n    return typeof(value) === 'object' && typeof(value.length) === 'number';\n}\n\nfunction toArray<T>(arrayLike: ArrayLike<T>): Array<T> {\n    if(isArrayLike(arrayLike)) {\n        return Array.prototype.slice.call(arrayLike, 0);\n    }else{\n        throw new TypeError('Expected ArrayLike');\n    }\n}\n\nfunction isMemberOfArrayLike(haystack: ArrayLike<any>,  needle: any) {\n    return Array.prototype.indexOf.call(haystack, needle) !== -1;\n}\n","import { Subscription, SubscriptionExecutor } from './subscriptions/subscription';\nimport { TrivialSubscription } from './subscriptions/trivial_subscription';\nimport { MatchingElementsSubscription, MatchingElementsChangedEvent } from './subscriptions/matching_elements_subscription';\nimport { ElementMatchesSubscription, ElementMatchesChangedEvent, ElementMatcher } from './subscriptions/element_matches_subscription';\nimport { EventSubscription, EventMatcher } from './subscriptions/event_subscription';\n\nexport class Scope {\n    static buildRootScope(element: Element): Scope {\n        let scope = new Scope(null, '<<root>>', element, null);\n\n        scope.activate();\n\n        return scope;\n    }\n\n    private readonly parentScope: Scope;\n    private readonly childScopes: Scope[] = [];    \n    private readonly element: Element;\n    private readonly name: string;\n\n    private isActivated: boolean = false;\n    private subscriptions: Subscription[] = [];\n\n    constructor(parentScope: Scope, name: string, element: Element, executor?: ScopeExecutor) {\n        this.parentScope = parentScope;\n        this.name = name;\n        this.element = element;\n\n        if(executor) {\n            executor.call(this, this, this.element);\n        }\n    }\n\n    getParentScope(): Scope {\n        return this.parentScope;\n    }\n\n    getChildScopes(): Scope[] {\n        return this.childScopes;\n    }\n\n    collectDescendantScopes(): Scope[] {\n        let scopes: Scope[] = [];\n\n        for(let scope of this.childScopes) {\n            scopes.push(scope, ...scope.collectDescendantScopes());\n        }\n\n        return scopes;\n    }\n\n    drawTree(): string {\n        return this.drawTreeLines().join('\\n');\n    }\n\n    drawTreeLines(): string[] {\n        let lines: string[] = [];\n\n        let self = this.name + ' (' + this.subscriptions.length + ')';\n\n        if(this.childScopes.length > 0) {\n            lines.push(self + ' {');\n\n            for(let scope of this.childScopes) {\n                for(let line of scope.drawTreeLines()) {\n                    lines.push('\\t' + line);\n                }\n            }\n\n            lines.push('}');\n        }else{\n            lines.push(self);\n        }\n\n        return lines;\n    }\n\n    getElement(): Element {\n        return this.element;\n    }\n\n    match(executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new TrivialSubscription(this.element, { connected: true }, executor));\n\n        return this;\n    }\n\n    unmatch(executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new TrivialSubscription(this.element, { disconnected: true }, executor));\n\n        return this;\n    }\n\n    select(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n        this.addSubscription(new MatchingElementsSubscription(this.element, matcher, this.buildSelectExecutor(String(matcher), executor)));\n\n        return this;\n    }\n\n    when(matcher: ElementMatcher, executor: ScopeExecutor): Scope {\n\t\tthis.addSubscription(new ElementMatchesSubscription(this.element, matcher, this.buildWhenExecutor(String(matcher), executor)));\n\n        return this;\n    }\n\n    on(eventMatcher: EventMatcher, executor: SubscriptionExecutor): Scope;\n    on(eventMatcher: EventMatcher, elementMatcher: ElementMatcher, executor: SubscriptionExecutor): Scope;\n    on(eventMatcher: EventMatcher, executorOrElementMatcher: SubscriptionExecutor | ElementMatcher, maybeExecutor?: SubscriptionExecutor): Scope {\n        let argumentsCount = arguments.length;\n\n        switch(argumentsCount) {\n            case 2:\n                return this.onWithTwoArguments(eventMatcher, <SubscriptionExecutor>executorOrElementMatcher);\n            case 3:\n                return this.onWithThreeArguments(eventMatcher, <ElementMatcher>executorOrElementMatcher, <SubscriptionExecutor>maybeExecutor);\n            default:\n                throw new TypeError(\"Failed to execute 'on' on 'Scope': 2 or 3 arguments required, but \" + argumentsCount + \" present.\");\n        }\n    }\n\n    private onWithTwoArguments(eventMatcher: EventMatcher, executor: SubscriptionExecutor): Scope {\n        this.addSubscription(new EventSubscription(this.element, eventMatcher, executor));\n\n        return this;\n    }\n\n    private onWithThreeArguments(eventMatcher: EventMatcher, elementMatcher: ElementMatcher, executor: SubscriptionExecutor): Scope {\n        this.select(elementMatcher, (scope) => {\n            scope.on(eventMatcher, executor)\n        });\n\n        return this;\n    }\n    \n    // This method is for testing\n    pristine(): void {\n        for(let subscription of this.subscriptions) {\n            subscription.disconnect();\n        }\n        \n        this.subscriptions.splice(0);\n    }\n\n    protected activate(): void {\n        if(!this.isActivated) {\n            this.isActivated = true;\n\n            for(let subscription of this.subscriptions) {\n                subscription.connect();\n            }\n        }\n    }\n\n    protected deactivate(): void {\n        if(this.isActivated) {\n            for(let subscription of this.subscriptions) {\n                subscription.disconnect();\n            }\n\n            let orphanedChildScope;\n            while(orphanedChildScope = this.childScopes[0]) {\n                console.warn('Decl bug!', this, 'attempted to deactivate without cleaning up', orphanedChildScope);\n                this.destroyChildScope(orphanedChildScope);\n            }\n\n            this.isActivated = false;            \n        }\n    }\n\n    private addSubscription(subscription: Subscription): void {\n        this.subscriptions.push(subscription);\n\n        if(this.isActivated) {\n            subscription.connect();\n        }\n    }\n\n    private removeSubscription(subscription: Subscription): void {\n        var index = this.subscriptions.indexOf(subscription);\n\n        if(index >= 0) {\n            subscription.disconnect();\n\n            this.subscriptions.splice(index, 1);\n        }\n    }\n\n    private buildSelectExecutor(name: string, executor: ScopeExecutor): SubscriptionExecutor {\n        let scopes: Scope[] = [];\n\n        return (event: MatchingElementsChangedEvent, element: Element) => {\n            for(let element of event.addedElements) {\n                let scope = this.createChildScope(name, element, executor);\n\n                scopes.push(scope);\n            }\n\n            for(let element of event.removedElements) {\n                for(let index = 0, length = scopes.length, scope : Scope; index < length; index++) {\n                    scope = scopes[index];\n\n                    if(scope.element === element) {\n                        this.destroyChildScope(scope);\n                        \n                        scopes.splice(index, 1);\n                        break;\n                    }\n                }\n            }\n        };\n    }\n\n    private buildWhenExecutor(name: string, executor: ScopeExecutor): SubscriptionExecutor {\n        let scope : Scope = null;\n\n        return (event: ElementMatchesChangedEvent, element: Element) => {\n            if(event.isMatching) {\n                scope = this.createChildScope('&' + name, this.element, executor);\n            }else{\n                this.destroyChildScope(scope);\n                scope = null;\n            }\n        };\n    }\n\n    private createChildScope(name: string, element: Element, executor?: ScopeExecutor): Scope {\n        let scope = new Scope(this, name, element, executor);\n        this.childScopes.push(scope);\n\n        scope.activate();\n\n        return scope;\n    }\n\n    private destroyChildScope(scope: Scope) {\n        let index = this.childScopes.indexOf(scope);\n\n        scope.deactivate();\n\n        if(index >= 0) {\n            this.childScopes.splice(index, 1);\n        }\n    }\n}\n\nexport interface ScopeExecutor { (scope: Scope, element: Element): void };\nexport { ElementMatcher, EventMatcher, SubscriptionExecutor };\n","import { Subscription, SubscriptionExecutor, SubscriptionEvent } from './subscription';\n\ninterface CommonJsRequire {\n    (id: string): any;\n}\n\ndeclare var require: CommonJsRequire;\nlet MutationObserver = require('mutation-observer'); // use polyfill\n\nexport abstract class BatchedMutationSubscription extends Subscription {\n    static readonly mutationObserverInit: MutationObserverInit = {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n    };\n\n    private isListening : boolean = false;\n    private handleMutationTimeout : any = null;\n\n    private readonly mutationCallback: MutationCallback;\n    private readonly mutationObserver: MutationObserver;\n\n    constructor(element: Element, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.mutationCallback = (): void => {\n            this.deferHandleMutations();\n        }\n\n        this.mutationObserver = new MutationObserver(this.mutationCallback);\n    }\n\n    protected startListening(): void {\n        if(!this.isListening) {\n            this.mutationObserver.observe(this.element, BatchedMutationSubscription.mutationObserverInit);\n\n            this.isListening = true;\n        }\n    }\n\n    protected stopListening(): void {\n        if(this.isListening) {\n            this.mutationObserver.disconnect();\n            this.handleMutationsNow();\n\n            this.isListening = false;\n        }\n    }\n    \n    protected abstract handleMutations(): void;\n\n    private deferHandleMutations(): void {\n        if(this.handleMutationTimeout === null) {\n            this.handleMutationTimeout = setTimeout(() => { \n                try {\n                    this.mutationObserver.takeRecords();\n                    this.handleMutations();\n                }finally{\n                    this.handleMutationTimeout = null;\n                }\n            }, 0);\n        }\n    }\n\n    private handleMutationsNow(): void {\n        if(this.handleMutationTimeout !== null) {\n            clearTimeout(this.handleMutationTimeout);\n            this.handleMutationTimeout = null;\n\n            this.handleMutations();            \n        }\n    }\n}\n\nexport { Subscription, SubscriptionExecutor, SubscriptionEvent };","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { ElementMatcher, ElementCollector } from '../element_collector';\n\nexport class ElementMatchesSubscription extends BatchedMutationSubscription {\n    readonly matcher: ElementMatcher;\n\n    private isConnected: boolean = false;\n    private isMatchingElement: boolean = false;\n\n    constructor(element: Element, matcher: ElementMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateIsMatchingElement(this.computeIsMatchingElement());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.updateIsMatchingElement(false);\n            this.stopListening();\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateIsMatchingElement(this.computeIsMatchingElement());\n    }\n\n    private updateIsMatchingElement(isMatchingElement: boolean): void {\n        let wasMatchingElement = this.isMatchingElement;\n        this.isMatchingElement = isMatchingElement;\n\n        if(wasMatchingElement !== isMatchingElement) {\n            let event = new ElementMatchesChangedEvent(this, isMatchingElement);\n\n            this.executor(event, this.element);\n        }\n    }\n\n    private computeIsMatchingElement(): boolean {\n        return ElementCollector.isMatchingElement(this.element, this.matcher);\n    }\n}\n\nexport class ElementMatchesChangedEvent extends SubscriptionEvent {\n    readonly isMatching: boolean;\n\n    constructor(elementMatchesSubscription: ElementMatchesSubscription, isMatching: boolean) {\n        super(elementMatchesSubscription, 'ElementMatchesChangedEvent');\n\n        this.isMatching = isMatching;\n    }\n}\n\nexport { ElementMatcher };\n","import { Subscription, SubscriptionExecutor } from './subscription';\n\nexport class EventSubscription extends Subscription {\n    readonly eventMatcher: EventMatcher;\n\n    private isConnected : boolean = false;    \n    private readonly eventListener: EventListener;\n    private readonly eventNames: string[];\n\n    constructor(element: Element, eventMatcher: EventMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.eventMatcher = eventMatcher;\n        this.eventNames = this.parseEventMatcher(this.eventMatcher);\n\n        this.eventListener = (event: Event): void => {\n            this.handleEvent(event);\n        }\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            for(let eventName of this.eventNames) {\n                this.element.addEventListener(eventName, this.eventListener, false);\n            }\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            for(let eventName of this.eventNames) {\n                this.element.removeEventListener(eventName, this.eventListener, false);\n            }            \n\n            this.isConnected = false;\n        }\n    }\n\n    private handleEvent(event: Event): void {\n        this.executor(event, this.element);         \n    }\n\n    private parseEventMatcher(eventMatcher: EventMatcher): string[] {\n        // TODO: Support all of the jQuery style event options\n        return eventMatcher.split(' ');\n    } \n}\n\nexport declare type EventMatcher = string;\n","import { BatchedMutationSubscription, SubscriptionExecutor, SubscriptionEvent } from './batched_mutation_subscription';\nimport { ElementMatcher, ElementCollector } from '../element_collector';\n\nexport class MatchingElementsSubscription extends BatchedMutationSubscription {\n    readonly matcher: ElementMatcher;\n\n    private isConnected: boolean = false;\n    private matchingElements: Element[] = [];\n\n    constructor(element: Element, matcher: ElementMatcher, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.matcher = matcher;\n    }\n\n    connect(): void {\n        if(!this.isConnected) {\n            this.updateMatchingElements(this.collectMatchingElements());\n            this.startListening();\n\n            this.isConnected = true;\n        }\n    }\n\n    disconnect(): void {\n        if(this.isConnected) {\n            this.updateMatchingElements([]);\n            this.stopListening();\n\n            this.isConnected = false;\n        }        \n    }\n\n    protected handleMutations(): void {\n        this.updateMatchingElements(this.collectMatchingElements());\n    }\n\n    private updateMatchingElements(matchingElements: Element[]): void {\n        let previouslyMatchingElements = this.matchingElements;\n\n        let addedElements = arraySubtract(matchingElements, previouslyMatchingElements);\n        let removedElements = arraySubtract(previouslyMatchingElements, matchingElements);\n\n        this.matchingElements = matchingElements;   \n        \n        if(addedElements.length > 0 || removedElements.length > 0) {\n            let event = new MatchingElementsChangedEvent(this, addedElements, removedElements);\n\n            this.executor(event, this.element);\n        }\n    }\n\n    private collectMatchingElements(): Element[] {\n        return ElementCollector.collectMatchingElements(this.element, this.matcher);\n    }\n}\n\nexport class MatchingElementsChangedEvent extends SubscriptionEvent {\n    readonly addedElements: Element[];\n    readonly removedElements: Element[];\n\n    constructor(matchingElementsSubscription: MatchingElementsSubscription, addedElements: Element[], removedElements: Element[]) {\n        super(matchingElementsSubscription, 'MatchingElementsChanged');\n\n        this.addedElements = addedElements;\n        this.removedElements = removedElements;\n    }\n}\n\nfunction arraySubtract<T>(minuend: T[], subtrahend: T[]): T[] {\n    let difference: T[] = [];\n\n    for(let member of minuend) {\n        if(subtrahend.indexOf(member) === -1) {\n            difference.push(member);\n        }\n    }\n\n    return difference;\n}","export abstract class Subscription {\n    protected readonly executor: SubscriptionExecutor;\n    protected readonly element: Element;\n    \n    constructor(element: Element, executor: SubscriptionExecutor) {\n        this.element = element;\n        this.executor = executor;\n    }\n\n    abstract connect() : void;\n    abstract disconnect() : void;\n}\n\nexport interface SubscriptionExecutor { \n    (event: Event | SubscriptionEvent, element: Element): void \n}\n\nexport class SubscriptionEvent {\n    readonly subscription: Subscription;\n    readonly name: string;\n\n    constructor(subscription: Subscription, name: string) {\n        this.subscription = subscription;\n        this.name = name;\n    }\n}\n","import { Subscription, SubscriptionExecutor, SubscriptionEvent } from './subscription';\n\nexport interface TrivialSubscriptionConfiguration {\n    connected?: boolean,\n    disconnected?: boolean\n}\n\nexport class ElementConnectionChangedEvent extends SubscriptionEvent {\n    readonly element: Element;\n    readonly isConnected: boolean;\n\n    constructor(trivialSubscription: TrivialSubscription, element: Element, isConnected: boolean) {\n        super(trivialSubscription, 'ElementConnected');\n\n        this.element = element;\n        this.isConnected = isConnected;\n    }\n}\n\nexport class TrivialSubscription extends Subscription {\n    private isConnected: boolean = false;\n    private config: TrivialSubscriptionConfiguration;\n\n    constructor(element: Element, config: TrivialSubscriptionConfiguration, executor: SubscriptionExecutor) {\n        super(element, executor);\n\n        this.config = config;\n    }\n\n    connect() {\n        if(!this.isConnected) {\n            this.isConnected = true;\n\n            if(this.config.connected) {\n                this.executor(this.buildElementConnectionChangedEvent(), this.element); \n            }\n        }\n    }\n\n    disconnect() {\n        if(this.isConnected) {\n            this.isConnected = false;\n\n            if(this.config.disconnected) {\n                this.executor(this.buildElementConnectionChangedEvent(), this.element);     \n            }\n        }\n    }\n    \n    private buildElementConnectionChangedEvent(): ElementConnectionChangedEvent {\n        return new ElementConnectionChangedEvent(this, this.element, this.isConnected);\n    }\n}"]}